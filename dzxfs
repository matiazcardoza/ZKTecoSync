main.py:
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import time
from datetime import datetime
import json
import requests
import sys
import argparse
import os
import socket
from urllib.parse import urljoin
from flask import Flask, jsonify, request
# Importaciones para Flask
from flask import Flask, jsonify
from flask_cors import CORS


try:
    from zk import ZK
    ZK_AVAILABLE = True
except ImportError:
    ZK_AVAILABLE = False

class ZKTecoApp:
    def __init__(self, root):
        self.root = root
        self.root.title("ZKTeco Sync v1.1 - Solo Asistencias")
        self.root.resizable(True, True)
        self.root.resizable(False, False)
        
        # Variables
        self.connection = None
        self.device = None
        self.is_connected = False
        
        # Variables para el servidor Flask
        self.flask_app = None
        self.flask_thread = None
        self.service_running = False

        # OPTIMIZADO: Parsing rápido de parámetros
        self.system_params = self.parse_system_params_fast()
        
        # Variables para dispositivo (ahora desde parámetros)
        self.device_info = None
        self.current_device_id = None
        
        # Verificar si el servicio ya está ejecutándose
        self.check_service_status()
        
        # Solo iniciar servidor Flask si el servicio NO está corriendo
        if not self.service_running:
            self.init_flask_server()
        
        self.setup_ui()
        
        if not ZK_AVAILABLE:
            self.log_text.insert(tk.END, "ADVERTENCIA: Librería 'pyzk' no encontrada.\n")
            self.log_text.insert(tk.END, "Instalar con: pip install pyzk\n\n")

    def check_service_status(self):
        """Verificar si el servicio ya está ejecutándose en el puerto 3322"""
        try:
            # Intentar hacer una petición al servicio
            response = requests.get('http://127.0.0.1:3322/estado', timeout=2)
            if response.status_code == 200:
                data = response.json()
                # Verificar si es el servicio (no la aplicación GUI)
                if data.get('tipo') == 'servicio_windows':
                    self.service_running = True
                    print("Servicio ZKTeco detectado ejecutándose")
                    return True
        except:
            pass
        
        # También verificar si el puerto está en uso
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                result = s.connect_ex(('127.0.0.1', 3322))
                if result == 0:
                    self.service_running = True
                    print("Puerto 3322 está en uso (posiblemente por el servicio)")
                    return True
        except:
            pass
        
        self.service_running = False
        return False

    def init_flask_server(self):
        """Inicializar servidor Flask para verificación remota"""
        try:
            self.flask_app = Flask(__name__)
            CORS(self.flask_app)
            
            # Ruta para verificar estado de la aplicación
            @self.flask_app.route('/estado', methods=['GET'])
            def estado():
                return jsonify({
                    'status': 'zkteco activo',
                    'instalado': True,
                    'version': '1.1',
                    'tipo': 'aplicacion_gui',
                    'conectado': self.is_connected,
                    'timestamp': datetime.now().isoformat()
                })
            
            @self.flask_app.route('/info', methods=['GET'])
            def info():
                device_info = {}
                if self.system_params:
                    device_info = {
                        'dispositivo': self.system_params.get('name', 'N/A'),
                        'ip': self.system_params.get('ip_address', 'N/A'),
                        'puerto': self.system_params.get('port', 'N/A')
                    }
                
                return jsonify({
                    'aplicacion': 'ZKTeco Sync GUI',
                    'version': '1.1',
                    'estado': 'activo',
                    'tipo': 'aplicacion_gui',
                    'dispositivo_configurado': bool(self.system_params),
                    'dispositivo_conectado': self.is_connected,
                    'device_info': device_info
                })
            
            # Ruta para verificar conectividad con dispositivo
            @self.flask_app.route('/ping-device', methods=['GET'])
            def ping_device():
                return jsonify({
                    'dispositivo_conectado': self.is_connected,
                    'puede_sincronizar': self.is_connected and bool(self.system_params)
                })
            
            # NUEVA RUTA: Cerrar servidor
            @self.flask_app.route('/shutdown', methods=['POST'])
            def shutdown():
                func = request.environ.get('werkzeug.server.shutdown')
                if func is None:
                    raise RuntimeError('Not running with the Werkzeug Server')
                func()
                return jsonify({'message': 'Server shutting down...'})
            
            def iniciar_servidor():
                try:
                    # CAMBIO CLAVE: daemon=False para que persista
                    self.flask_app.run(
                        port=3322, 
                        host='127.0.0.1', 
                        debug=False, 
                        use_reloader=False,
                        threaded=True
                    )
                except Exception as e:
                    print(f"Error iniciando servidor Flask: {e}")
            
            # CAMBIO CLAVE: daemon=False
            self.flask_thread = threading.Thread(target=iniciar_servidor, daemon=False)
            self.flask_thread.start()
            
            print("Servidor Flask iniciado en http://127.0.0.1:3322")
            
        except Exception as e:
            print(f"Error configurando servidor Flask: {e}")

    def parse_system_params_fast(self):
        """Parsing optimizado de parámetros del sistema"""
        try:
            # Método más rápido: buscar directamente en sys.argv
            for i, arg in enumerate(sys.argv):
                if arg == '--params-system' and i + 1 < len(sys.argv):
                    param_value = sys.argv[i + 1]
                    try:
                        return json.loads(param_value)
                    except json.JSONDecodeError:
                        # Intentar limpiar el JSON una sola vez
                        cleaned = param_value.strip().replace(' :', ':').replace(': ', ':')
                        try:
                            return json.loads(cleaned)
                        except:
                            return None
            
            # Fallback: variable de entorno
            env_params = os.environ.get('ZKTECO_PARAMS')
            if env_params:
                return json.loads(env_params)
            
            return None
            
        except Exception:
            # Sin prints de debug para mayor velocidad
            return None
    
    def setup_ui(self):
        # Marco principal
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configurar device_info una sola vez
        if self.system_params:
            self.device_info = {
                'id': self.system_params.get('id'),
                'name': self.system_params.get('name', ''),
                'ip_address': self.system_params.get('ip_address', ''),
                'port': self.system_params.get('port', 4370)
            }
            self.current_device_id = self.device_info['id']

        # Configuración de conexión (simplificada)
        config_frame = ttk.LabelFrame(main_frame, text="Configuración de Conexión", padding="10")
        config_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        if self.system_params:
            # Layout más eficiente
            labels_data = [
                ("Dispositivo:", self.device_info['name']),
                ("IP:", self.device_info['ip_address']),
                ("Puerto:", str(self.device_info['port']))
            ]
            
            for i, (label_text, value_text) in enumerate(labels_data):
                ttk.Label(config_frame, text=label_text).grid(row=i, column=0, sticky=tk.W, padx=(0, 10))
                value_label = ttk.Label(config_frame, text=value_text, font=('Arial', 9, 'bold') if i == 0 else None)
                value_label.grid(row=i, column=1, sticky=tk.W)
        else:
            error_label = ttk.Label(config_frame, text="No se puede continuar sin parámetros del dispositivo", foreground='red')
            error_label.grid(row=0, column=0, columnspan=2)

        # Mostrar información del servidor Flask
        server_frame = ttk.LabelFrame(main_frame, text="Estado del Servidor", padding="10")
        server_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        if self.service_running:
            ttk.Label(server_frame, text="Estado:").grid(row=0, column=0, sticky=tk.W)
            ttk.Label(server_frame, text="Servicio de Windows ejecutándose", font=('Arial', 9, 'bold'), foreground='green').grid(row=0, column=1, sticky=tk.W, padx=(10, 0))
            ttk.Label(server_frame, text="URL:").grid(row=1, column=0, sticky=tk.W)
            ttk.Label(server_frame, text="http://127.0.0.1:3322/estado", font=('Arial', 9)).grid(row=1, column=1, sticky=tk.W, padx=(10, 0))
        else:
            ttk.Label(server_frame, text="Estado:").grid(row=0, column=0, sticky=tk.W)
            ttk.Label(server_frame, text="Aplicación GUI activa", font=('Arial', 9, 'bold'), foreground='blue').grid(row=0, column=1, sticky=tk.W, padx=(10, 0))
            ttk.Label(server_frame, text="URL:").grid(row=1, column=0, sticky=tk.W)
            ttk.Label(server_frame, text="http://127.0.0.1:3322/estado", font=('Arial', 9)).grid(row=1, column=1, sticky=tk.W, padx=(10, 0))

        # Timeout
        ttk.Label(config_frame, text="Timeout (s):").grid(row=3, column=0, sticky=tk.W, padx=(0, 10), pady=(10, 0))
        self.timeout_var = tk.StringVar(value="5")
        timeout_entry = ttk.Entry(config_frame, textvariable=self.timeout_var, width=10)
        timeout_entry.grid(row=3, column=1, sticky=tk.W, pady=(10, 0))

        # Botones de conexión
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=2, pady=(0, 10))
        
        # Solo habilitar botones si tenemos parámetros
        button_state = "normal" if self.system_params else "disabled"
        
        self.test_btn = ttk.Button(button_frame, text="Probar Conexión", command=self.test_connection, state=button_state)
        self.test_btn.grid(row=0, column=0, padx=(0, 10))
        
        self.connect_btn = ttk.Button(button_frame, text="Conectar", command=self.connect_device, state=button_state)
        self.connect_btn.grid(row=0, column=1, padx=(0, 10))
        
        self.disconnect_btn = ttk.Button(button_frame, text="Desconectar", command=self.disconnect_device, state="disabled")
        self.disconnect_btn.grid(row=0, column=2)
        
        # Indicador de estado
        status_frame = ttk.Frame(main_frame)
        status_frame.grid(row=3, column=0, columnspan=2, pady=(0, 10))
        
        ttk.Label(status_frame, text="Estado:").grid(row=0, column=0, padx=(0, 10))
        self.status_var = tk.StringVar(value="Desconectado")
        self.status_label = ttk.Label(status_frame, textvariable=self.status_var, foreground="red")
        self.status_label.grid(row=0, column=1)
        
        # Botón de extracción de asistencias únicamente
        data_frame = ttk.LabelFrame(main_frame, text="Extracción y Sincronización", padding="10")
        data_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.extract_attendance_btn = ttk.Button(data_frame, text="Extraer y Enviar Asistencias", command=self.extract_attendance, state="disabled")
        self.extract_attendance_btn.grid(row=0, column=0)
        
        # Log de eventos
        log_frame = ttk.LabelFrame(main_frame, text="Log de Eventos", padding="10")
        log_frame.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        
        # Texto con scrollbar
        log_scroll_frame = ttk.Frame(log_frame)
        log_scroll_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.log_text = tk.Text(log_scroll_frame, height=15, width=70)
        scrollbar = ttk.Scrollbar(log_scroll_frame, orient="vertical", command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=scrollbar.set)
        
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Botón para limpiar log
        ttk.Button(log_frame, text="Limpiar Log", command=self.clear_log).grid(row=1, column=0, pady=(10, 0))
        
        # Configurar weights para redimensionamiento
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(5, weight=1)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        log_scroll_frame.columnconfigure(0, weight=1)
        log_scroll_frame.rowconfigure(0, weight=1)
        
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        
        # Log inicial - OPTIMIZADO
        self.log("Aplicación iniciada - Solo sincronización de asistencias")
        
        if self.service_running:
            self.log("NOTA: Servicio ZKTeco detectado ejecutándose")
            self.log("La aplicación GUI funciona en modo complementario")
        else:
            self.log("Servidor Flask iniciado en puerto 3322")
        
        if ZK_AVAILABLE:
            self.log("Librería ZK cargada correctamente")
        else:
            self.log("ADVERTENCIA: Instalar con 'pip install pyzk requests flask flask-cors'")
        
        # Log de parámetros - SIMPLIFICADO
        if self.system_params:
            self.log(f"✓ Dispositivo configurado: {self.device_info['name']} ({self.device_info['ip_address']}:{self.device_info['port']})")
        else:
            self.log("✗ No se recibieron parámetros del sistema")

    def log(self, message):
        """Agregar mensaje al log con timestamp"""
        try:
            if hasattr(self, 'log_text') and self.log_text:
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.root.after(0, lambda: self._safe_log_insert(timestamp, message))
            else:
                print(f"[LOG] {message}")
        except Exception as e:
            print(f"[ERROR LOG] {message} - Error: {e}")

    def _safe_log_insert(self, timestamp, message):
        """Insertar mensaje en el log de forma segura"""
        try:
            self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
            self.log_text.see(tk.END)
            self.root.update_idletasks()
        except Exception as e:
            print(f"[ERROR LOG INSERT] {message} - Error: {e}")
    
    def clear_log(self):
        """Limpiar el log"""
        self.log_text.delete(1.0, tk.END)
    
    def test_connection(self):
        """Probar conexión con el dispositivo - OPTIMIZADO"""
        if not ZK_AVAILABLE:
            messagebox.showerror("Error", "Librería pyzk no está instalada")
            return
            
        if not self.system_params:
            messagebox.showerror("Error", "No hay parámetros de dispositivo disponibles")
            return
            
        def test_conn():
            try:
                self.test_btn.config(state="disabled")
                self.log("Probando conexión...")
                
                ip = self.device_info['ip_address']
                port = int(self.device_info['port'])
                timeout = int(self.timeout_var.get())
                
                # Log reducido para mayor velocidad
                self.log(f"Conectando a {ip}:{port}")
                
                zk = ZK(ip, port=port, timeout=timeout)
                conn = zk.connect()
                
                if conn:
                    # Obtener solo información de asistencias
                    try:
                        attendance_count = len(conn.get_attendance())
                        
                        conn.disconnect()
                        
                        self.log("✓ Conexión exitosa!")
                        self.log(f"  - Registros de asistencia: {attendance_count}")
                        
                        messagebox.showinfo("Éxito", "Conexión establecida correctamente")
                    except Exception as e:
                        conn.disconnect()
                        self.log(f"✓ Conexión establecida (error obteniendo detalles: {str(e)})")
                        messagebox.showinfo("Éxito", "Conexión establecida correctamente")
                else:
                    self.log("✗ Error: No se pudo establecer conexión")
                    messagebox.showerror("Error", "No se pudo conectar al dispositivo")
                    
            except Exception as e:
                self.log(f"✗ Error de conexión: {str(e)}")
                messagebox.showerror("Error", f"Error de conexión: {str(e)}")
            finally:
                self.test_btn.config(state="normal")
        
        # Ejecutar en hilo separado
        threading.Thread(target=test_conn, daemon=True).start()
    
    def connect_device(self):
        """Conectar al dispositivo"""
        if not ZK_AVAILABLE:
            messagebox.showerror("Error", "Librería pyzk no está instalada")
            return
            
        if not self.system_params:
            messagebox.showerror("Error", "No hay parámetros de dispositivo disponibles")
            return
            
        def connect():
            try:
                self.connect_btn.config(state="disabled")
                self.log("Conectando al dispositivo...")
                
                ip = self.device_info['ip_address']
                port = int(self.device_info['port'])
                timeout = int(self.timeout_var.get())
                
                self.device = ZK(ip, port=port, timeout=timeout)
                self.connection = self.device.connect()
                
                if self.connection:
                    self.is_connected = True
                    self.status_var.set("Conectado")
                    self.status_label.config(foreground="green")
                    
                    # Habilitar solo botón de extracción de asistencias
                    self.extract_attendance_btn.config(state="normal")
                    self.disconnect_btn.config(state="normal")
                    
                    self.log("✓ Dispositivo conectado exitosamente")
                    messagebox.showinfo("Éxito", "Dispositivo conectado correctamente")
                else:
                    self.log("✗ Error: No se pudo conectar")
                    messagebox.showerror("Error", "No se pudo conectar al dispositivo")
                    
            except Exception as e:
                self.log(f"✗ Error de conexión: {str(e)}")
                messagebox.showerror("Error", f"Error de conexión: {str(e)}")
            finally:
                if not self.is_connected:
                    self.connect_btn.config(state="normal")
        
        threading.Thread(target=connect, daemon=True).start()
    
    def disconnect_device(self):
        """Desconectar del dispositivo"""
        try:
            if self.connection:
                self.connection.disconnect()
                self.connection = None
                self.device = None
                
            self.is_connected = False
            self.status_var.set("Desconectado")
            self.status_label.config(foreground="red")
            
            # Deshabilitar botón de asistencias
            self.extract_attendance_btn.config(state="disabled")
            self.disconnect_btn.config(state="disabled")
            self.connect_btn.config(state="normal")
            
            self.log("Dispositivo desconectado")
            
        except Exception as e:
            self.log(f"Error al desconectar: {str(e)}")
    
    def extract_attendance(self):
        """Extraer registros de asistencia y enviar a la nube"""
        if not self.connection:
            return
            
        def extract():
            try:
                self.extract_attendance_btn.config(state="disabled")
                self.log("Extrayendo registros de asistencia...")
                
                attendance = self.connection.get_attendance()
                
                if attendance:
                    attendance_data = []
                    for record in attendance:
                        attendance_data.append({
                            'uid': record.uid,
                            'id': record.user_id,
                            'timestamp': record.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                            'state': record.status,
                            'type': record.punch
                        })
                    
                    self.log(f"✓ {len(attendance)} registros extraídos del dispositivo")
                    
                    # Enviar a la nube
                    cloud_success = self.send_data_to_cloud('attendance', attendance_data, '/api/zkteco/attendance')
                    
                    # Mensaje de resultado
                    if cloud_success:
                        messagebox.showinfo("Éxito", "Asistencias sincronizadas correctamente")
                        self.log("✓ Sincronización completada exitosamente")
                    else:
                        messagebox.showerror("Error", "No se pudo sincronizar las asistencias")
                        
                else:
                    self.log("No se encontraron registros de asistencia")
                    messagebox.showinfo("Información", "No se encontraron registros de asistencia en el dispositivo")
                    
            except Exception as e:
                self.log(f"✗ Error extrayendo asistencias: {str(e)}")
                messagebox.showerror("Error", f"Error extrayendo asistencias: {str(e)}")
            finally:
                self.extract_attendance_btn.config(state="normal")
        
        threading.Thread(target=extract, daemon=True).start()

    def send_data_to_cloud(self, data_type, data, endpoint):
        """Enviar solo los datos a Laravel API"""
        try:
            self.log(f"Enviando {data_type} a la nube...")
            
            # URL base de api Local
            #base_url = "http://localhost:8000/api/zkteco/attendance"
            # URL bade de api producción
            base_url = "https://sistemas.regionpuno.gob.pe/asiss-api/api/zkteco/attendance"

            url = urljoin(base_url, endpoint)
            
            # Payload simplificado - solo los datos
            payload = data  # Directamente el array de datos
            
            # Headers para Laravel
            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            }
            
            # Log para debugging
            self.log(f"Enviando a: {url}")
            self.log(f"Cantidad de registros: {len(data)}")
            
            # Hacer la petición POST
            response = requests.post(
                url, 
                json=payload,  # Enviar directamente el array
                headers=headers,
                timeout=60
            )
            
            # Log de respuesta
            self.log(f"Código de respuesta: {response.status_code}")
            
            if response.status_code == 200:
                try:
                    response_data = response.json()
                    self.log(f"✓ {data_type.title()} enviados exitosamente")
                    # Si Laravel devuelve información adicional
                    if isinstance(response_data, dict) and 'message' in response_data:
                        self.log(f"  - Respuesta: {response_data['message']}")
                    return True
                except:
                    # Si Laravel no devuelve JSON, pero el status es 200
                    self.log(f"✓ {data_type.title()} enviados exitosamente")
                    return True
            else:
                try:
                    error_data = response.json()
                    self.log(f"✗ Error HTTP {response.status_code}: {error_data.get('message', 'Error desconocido')}")
                except:
                    self.log(f"✗ Error HTTP {response.status_code}: {response.text[:200]}")
                return False
                
        except requests.exceptions.Timeout:
            self.log(f"✗ Timeout enviando a la nube (60s)")
            return False
        except requests.exceptions.ConnectionError:
            self.log(f"✗ Error de conexión con el servidor")
            return False
        except Exception as e:
            self.log(f"✗ Error enviando a la nube: {str(e)}")
            return False


def main():
    root = tk.Tk()
    app = ZKTecoApp(root)
    
    # Manejo del cierre de ventana
    def on_closing():
        if app.is_connected:
            app.disconnect_device()
        
        # NUEVO: Mostrar opción para mantener servidor activo
        if not app.service_running and app.flask_thread and app.flask_thread.is_alive():
            result = messagebox.askyesno(
                "Cerrar Aplicación", 
                "¿Desea mantener el servidor activo en segundo plano?\n\n" +
                "Sí: El servidor seguirá ejecutándose (puerto 3322)\n" +
                "No: Cerrar completamente la aplicación"
            )
            
            if not result:  # Usuario eligió "No" - cerrar todo
                try:
                    # Intentar cerrar el servidor Flask
                    import requests
                    requests.post('http://127.0.0.1:3322/shutdown', timeout=2)
                except:
                    pass
        
        root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()

zkteco_service.py:
import sys
import os
import time
import json
import socket
import threading
from datetime import datetime
import traceback
import subprocess

# Importaciones de servicio de Windows
try:
    import win32serviceutil
    import win32service
    import win32event
    import servicemanager
    WIN32_AVAILABLE = True
except ImportError as e:
    WIN32_AVAILABLE = False
    print(f"ERROR: Librerías win32 no disponibles: {e}")
    print("Instale: pip install pywin32")

# Importaciones para Flask
try:
    from flask import Flask, jsonify
    from flask_cors import CORS
    FLASK_AVAILABLE = True
except ImportError as e:
    FLASK_AVAILABLE = False
    print(f"ERROR: Flask no disponible: {e}")

# Importaciones para ZKTeco
try:
    from zk import ZK
    ZK_AVAILABLE = True
except ImportError:
    ZK_AVAILABLE = False

class ZKTecoService(win32serviceutil.ServiceFramework):
    _svc_name_ = "ZKTecoSync"
    _svc_display_name_ = "ZKTeco Sync Service"
    _svc_description_ = "Servicio de sincronización para dispositivos ZKTeco - API REST en puerto 3322"
    
    def __init__(self, args):
        if not WIN32_AVAILABLE:
            raise Exception("Librerías win32 no disponibles")
            
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.running = True
        
        # Variables del servicio
        self.flask_app = None
        self.flask_thread = None
        self.device_connection = None
        self.system_params = None
        
        # Determinar directorio base del servicio
        if hasattr(sys, '_MEIPASS'):
            # Ejecutándose desde PyInstaller
            self.base_dir = os.path.dirname(sys.executable)
        else:
            # Ejecutándose desde Python
            self.base_dir = os.path.dirname(os.path.abspath(__file__))
        
        # Log del servicio
        self.log_dir = os.path.join(self.base_dir, 'logs')
        self.log_file = os.path.join(self.log_dir, 'service.log')
        
        # Crear directorios necesarios
        self.ensure_directories()

    def ensure_directories(self):
        """Crear directorios necesarios con manejo de errores"""
        directories = [
            os.path.join(self.base_dir, 'logs'),
            os.path.join(self.base_dir, 'config')
        ]
        
        for directory in directories:
            try:
                if not os.path.exists(directory):
                    os.makedirs(directory, exist_ok=True)
                    self.log_service(f"Directorio creado: {directory}")
            except Exception as e:
                # Log a archivo temporal si no se puede crear el directorio de logs
                temp_log = os.path.join(os.environ.get('TEMP', '.'), 'zkteco_service_error.log')
                try:
                    with open(temp_log, 'a', encoding='utf-8') as f:
                        f.write(f"[{datetime.now()}] Error creando directorio {directory}: {e}\n")
                except:
                    pass

    def SvcStop(self):
        """Detener el servicio"""
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop)
        self.running = False
        self.log_service("Servicio detenido")

    def SvcDoRun(self):
        """Ejecutar el servicio"""
        try:
            servicemanager.LogMsg(
                servicemanager.EVENTLOG_INFORMATION_TYPE,
                servicemanager.PYS_SERVICE_STARTED,
                (self._svc_name_, '')
            )
            
            self.log_service("Iniciando servicio ZKTeco Sync...")
            self.main()
        except Exception as e:
            self.log_service(f"Error crítico en SvcDoRun: {e}")
            self.log_service(f"Traceback: {traceback.format_exc()}")
            raise

    def log_service(self, message):
        """Log del servicio con manejo robusto de errores"""
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_line = f"[{timestamp}] {message}\n"
            
            # Intentar escribir al archivo de log principal
            if os.path.exists(self.log_dir):
                with open(self.log_file, 'a', encoding='utf-8') as f:
                    f.write(log_line)
            else:
                # Si no existe el directorio, usar log temporal
                temp_log = os.path.join(os.environ.get('TEMP', '.'), 'zkteco_service.log')
                with open(temp_log, 'a', encoding='utf-8') as f:
                    f.write(log_line)
                    
            # También enviar al log de eventos de Windows
            try:
                servicemanager.LogInfoMsg(f"ZKTeco: {message}")
            except:
                pass
                
        except Exception as e:
            # Último recurso: escribir a stdout/stderr
            try:
                print(f"LOG ERROR ({e}): {message}")
            except:
                pass

    def is_port_in_use(self, port):
        """Verificar si un puerto está en uso"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                return s.connect_ex(('127.0.0.1', port)) == 0
        except Exception as e:
            self.log_service(f"Error verificando puerto {port}: {e}")
            return False

    def load_device_params(self):
        """Cargar parámetros del dispositivo desde archivo de configuración"""
        try:
            config_file = os.path.join(self.base_dir, 'config', 'device.json')
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    self.system_params = json.load(f)
                    self.log_service(f"Parámetros cargados: {self.system_params.get('name', 'N/A')}")
                    return True
            else:
                self.log_service(f"No se encontró archivo de configuración: {config_file}")
                self.create_default_config()
                return False
        except Exception as e:
            self.log_service(f"Error cargando configuración: {e}")
            return False

    def create_default_config(self):
        """Crear archivo de configuración por defecto"""
        try:
            config_file = os.path.join(self.base_dir, 'config', 'device.json')
            default_config = {
                "id": "1",
                "name": "Dispositivo ZKTeco",
                "ip_address": "192.168.1.100",
                "port": 4370
            }
            
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(default_config, f, indent=2, ensure_ascii=False)
                
            self.log_service(f"Archivo de configuración por defecto creado: {config_file}")
            
        except Exception as e:
            self.log_service(f"Error creando configuración por defecto: {e}")

    def init_flask_server(self):
        """Inicializar servidor Flask"""
        try:
            if not FLASK_AVAILABLE:
                self.log_service("ERROR: Flask no está disponible")
                return False
                
            self.flask_app = Flask(__name__)
            CORS(self.flask_app)
            
            # Configurar logging de Flask para que sea silencioso
            import logging
            log = logging.getLogger('werkzeug')
            log.setLevel(logging.ERROR)
            
            # Ruta para verificar estado
            @self.flask_app.route('/estado', methods=['GET'])
            def estado():
                return jsonify({
                    'status': 'servicio activo',
                    'instalado': True,
                    'version': '1.2',
                    'tipo': 'servicio_windows',
                    'conectado': self.device_connection is not None,
                    'timestamp': datetime.now().isoformat(),
                    'base_dir': self.base_dir,
                    'flask_available': FLASK_AVAILABLE,
                    'zk_available': ZK_AVAILABLE
                })
            
            @self.flask_app.route('/info', methods=['GET'])
            def info():
                device_info = {}
                if self.system_params:
                    device_info = {
                        'dispositivo': self.system_params.get('name', 'N/A'),
                        'ip': self.system_params.get('ip_address', 'N/A'),
                        'puerto': self.system_params.get('port', 'N/A')
                    }
                
                return jsonify({
                    'aplicacion': 'ZKTeco Sync Service',
                    'version': '1.2',
                    'estado': 'servicio activo',
                    'tipo': 'servicio_windows',
                    'dispositivo_configurado': bool(self.system_params),
                    'dispositivo_conectado': self.device_connection is not None,
                    'device_info': device_info,
                    'base_directory': self.base_dir
                })
            
            @self.flask_app.route('/ping-device', methods=['GET'])
            def ping_device():
                return jsonify({
                    'dispositivo_conectado': self.device_connection is not None,
                    'puede_sincronizar': self.device_connection is not None and bool(self.system_params),
                    'zk_library_available': ZK_AVAILABLE
                })

            @self.flask_app.route('/logs', methods=['GET'])
            def get_logs():
                """Endpoint para obtener los últimos logs"""
                try:
                    if os.path.exists(self.log_file):
                        with open(self.log_file, 'r', encoding='utf-8') as f:
                            lines = f.readlines()
                            # Devolver las últimas 50 líneas
                            return jsonify({
                                'logs': lines[-50:] if len(lines) > 50 else lines,
                                'total_lines': len(lines)
                            })
                    else:
                        return jsonify({'logs': [], 'error': 'Archivo de log no encontrado'})
                except Exception as e:
                    return jsonify({'logs': [], 'error': str(e)})

            def run_flask():
                try:
                    self.log_service("Iniciando servidor Flask en puerto 3322...")
                    self.flask_app.run(
                        port=3322,
                        host='127.0.0.1',
                        debug=False,
                        use_reloader=False,
                        threaded=True
                    )
                except Exception as e:
                    self.log_service(f"Error en servidor Flask: {e}")
                    self.log_service(f"Traceback: {traceback.format_exc()}")

            self.flask_thread = threading.Thread(target=run_flask, daemon=True)
            self.flask_thread.start()
            
            # Esperar un momento para que Flask se inicie
            time.sleep(3)
            
            # Verificar que realmente esté escuchando
            if self.is_port_in_use(3322):
                self.log_service("✓ Servidor Flask iniciado correctamente en puerto 3322")
                return True
            else:
                self.log_service("✗ Servidor Flask no está escuchando en puerto 3322")
                return False
            
        except Exception as e:
            self.log_service(f"Error configurando Flask: {e}")
            self.log_service(f"Traceback: {traceback.format_exc()}")
            return False

    def test_device_connection(self):
        """Probar conexión con dispositivo cada 5 minutos"""
        while self.running:
            try:
                if self.system_params and ZK_AVAILABLE:
                    ip = self.system_params.get('ip_address')
                    port = int(self.system_params.get('port', 4370))
                    
                    zk = ZK(ip, port=port, timeout=5)
                    conn = zk.connect()
                    
                    if conn:
                        if not self.device_connection:
                            self.log_service(f"✓ Conectado a dispositivo {ip}:{port}")
                        self.device_connection = conn
                    else:
                        if self.device_connection:
                            self.log_service(f"✗ Perdida conexión con dispositivo {ip}:{port}")
                        self.device_connection = None
                elif not ZK_AVAILABLE:
                    if not hasattr(self, '_zk_warning_logged'):
                        self.log_service("Advertencia: Librería ZK no disponible para conexión con dispositivo")
                        self._zk_warning_logged = True
                        
                # Esperar 5 minutos antes de la siguiente verificación
                for _ in range(300):  # 5 minutos = 300 segundos
                    if not self.running:
                        break
                    time.sleep(1)
                    
            except Exception as e:
                if self.device_connection:
                    self.log_service(f"Error de conexión con dispositivo: {e}")
                self.device_connection = None
                time.sleep(30)  # Esperar 30 segundos si hay error

    def main(self):
        """Función principal del servicio"""
        try:
            self.log_service("=== INICIANDO SERVICIO ZKTECO SYNC ===")
            self.log_service(f"Directorio base: {self.base_dir}")
            self.log_service(f"Python executable: {sys.executable}")
            self.log_service(f"WIN32 disponible: {WIN32_AVAILABLE}")
            self.log_service(f"Flask disponible: {FLASK_AVAILABLE}")
            self.log_service(f"ZK disponible: {ZK_AVAILABLE}")
            
            # Verificar si el puerto ya está en uso
            if self.is_port_in_use(3322):
                self.log_service("ERROR: Puerto 3322 ya está en uso. Cerrando servicio.")
                return

            # Cargar configuración del dispositivo
            self.load_device_params()
            
            # Inicializar servidor Flask
            if not self.init_flask_server():
                self.log_service("ERROR: No se pudo iniciar servidor Flask")
                return
            
            # Iniciar monitoreo de dispositivo en hilo separado
            device_thread = threading.Thread(target=self.test_device_connection, daemon=True)
            device_thread.start()
            
            self.log_service("✓ Servicio ZKTeco iniciado correctamente")
            
            # Mantener el servicio ejecutándose
            while self.running:
                # Esperar por señal de parada
                if win32event.WaitForSingleObject(self.hWaitStop, 1000) == win32event.WAIT_OBJECT_0:
                    break
                    
        except Exception as e:
            self.log_service(f"ERROR CRÍTICO en servicio principal: {e}")
            self.log_service(f"Traceback completo: {traceback.format_exc()}")
            raise
        finally:
            try:
                if self.device_connection:
                    self.device_connection.disconnect()
            except:
                pass
            self.log_service("=== SERVICIO FINALIZADO ===")


def install_service_with_validation():
    """Instalar servicio con validaciones adicionales"""
    print("=== INSTALACIÓN DE SERVICIO ZKTECO SYNC ===")
    
    # Verificar dependencias críticas
    print("Verificando dependencias...")
    
    missing_deps = []
    
    if not WIN32_AVAILABLE:
        missing_deps.append("pywin32 (win32serviceutil, win32service, win32event, servicemanager)")
    
    if not FLASK_AVAILABLE:
        missing_deps.append("flask, flask-cors")
    
    if missing_deps:
        print(f"ERROR: Faltan dependencias críticas:")
        for dep in missing_deps:
            print(f"  - {dep}")
        print("\nInstale las dependencias con:")
        print("  pip install pywin32 flask flask-cors")
        return False
    
    print("✓ Todas las dependencias están disponibles")
    
    # Verificar permisos de administrador
    try:
        import ctypes
        is_admin = ctypes.windll.shell32.IsUserAnAdmin()
        if not is_admin:
            print("ERROR: Se requieren permisos de administrador")
            print("Ejecute como administrador")
            return False
    except:
        print("Advertencia: No se pudo verificar permisos de administrador")
    
    print("✓ Permisos de administrador confirmados")
    
    # Instalar servicio
    try:
        print("Instalando servicio...")
        win32serviceutil.InstallService(
            ZKTecoService,
            ZKTecoService._svc_name_,
            ZKTecoService._svc_display_name_,
            description=ZKTecoService._svc_description_
        )
        print("✓ Servicio instalado correctamente")
        return True
        
    except Exception as e:
        print(f"ERROR instalando servicio: {e}")
        print(f"Detalles: {traceback.format_exc()}")
        return False


def create_default_config():
    """Crear archivo de configuración por defecto"""
    try:
        # Determinar directorio base
        if hasattr(sys, '_MEIPASS'):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))
            
        config_dir = os.path.join(base_dir, 'config')
        os.makedirs(config_dir, exist_ok=True)
        
        config_file = os.path.join(config_dir, 'device.json')
        if not os.path.exists(config_file):
            default_config = {
                "id": "1",
                "name": "Dispositivo ZKTeco",
                "ip_address": "192.168.1.100",
                "port": 4370
            }
            
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(default_config, f, indent=2, ensure_ascii=False)
            
            print(f"✓ Archivo de configuración creado: {config_file}")
        else:
            print(f"✓ Archivo de configuración ya existe: {config_file}")
            
        print("IMPORTANTE: Edite este archivo con los datos de su dispositivo")
        return True
        
    except Exception as e:
        print(f"Error creando configuración por defecto: {e}")
        return False


if __name__ == '__main__':
    if len(sys.argv) == 1:
        # Sin argumentos, mostrar ayuda y crear configuración
        print("=== SERVICIO ZKTECO SYNC v1.2 ===")
        print(f"WIN32 disponible: {WIN32_AVAILABLE}")
        print(f"Flask disponible: {FLASK_AVAILABLE}")
        print(f"ZK disponible: {ZK_AVAILABLE}")
        print()
        
        create_default_config()
        
        print("\nUso:")
        print("  python zkteco_service.py install    - Instalar servicio")
        print("  python zkteco_service.py remove     - Desinstalar servicio")
        print("  python zkteco_service.py start      - Iniciar servicio")
        print("  python zkteco_service.py stop       - Detener servicio")
        print("  python zkteco_service.py debug      - Ejecutar en modo debug")
        print("  python zkteco_service.py validate   - Validar instalación")
        
    elif 'debug' in sys.argv:
        # Modo debug para pruebas
        print("=== MODO DEBUG ===")
        if not WIN32_AVAILABLE:
            print("ERROR: Librerías win32 no disponibles en modo debug")
            print("Este modo simula el servicio pero requiere las librerías")
            sys.exit(1)
            
        service = ZKTecoService([])
        service.main()
        
    elif 'validate' in sys.argv:
        # Validar instalación
        print("=== VALIDACIÓN DE INSTALACIÓN ===")
        print(f"WIN32 disponible: {WIN32_AVAILABLE}")
        print(f"Flask disponible: {FLASK_AVAILABLE}")
        print(f"ZK disponible: {ZK_AVAILABLE}")
        
        if WIN32_AVAILABLE and FLASK_AVAILABLE:
            print("✓ Todas las dependencias críticas están disponibles")
        else:
            print("✗ Faltan dependencias críticas")
            
    elif 'install' in sys.argv:
        # Instalación con validaciones
        if install_service_with_validation():
            print("✓ Instalación completada")
        else:
            print("✗ Error en la instalación")
            sys.exit(1)
            
    else:
        # Comandos estándar de servicio de Windows
        if not WIN32_AVAILABLE:
            print("ERROR: Librerías win32 no disponibles")
            print("Instale con: pip install pywin32")
            sys.exit(1)
            
        win32serviceutil.HandleCommandLine(ZKTecoService)

y este es ZKTeco-Sync-installer.iss:
[Setup]
AppName=ZKTeco Sync
AppVersion=1.1
AppPublisher=Sistema de Asistencias
DefaultDirName={autopf}\ZKTeco Sync
DefaultGroupName=ZKTeco Sync
AllowNoIcons=yes
LicenseFile=LICENSE.txt
InfoBeforeFile=README.txt
OutputDir=output
OutputBaseFilename=ZKTeco-Sync-Setup-v1.1
Compression=lzma
SolidCompression=yes
WizardStyle=modern
PrivilegesRequired=admin
SetupLogging=yes

[Languages]
Name: "spanish"; MessagesFile: "compiler:Languages\Spanish.isl"

[Tasks]
Name: "desktopicon"; Description: "Crear acceso directo en el escritorio"; GroupDescription: "Accesos directos adicionales:"; Flags: unchecked
Name: "installservice"; Description: "Instalar servicio de Windows (recomendado)"; GroupDescription: "Servicios:"; Flags: checkedonce

[Files]
; Archivo principal ejecutable (GUI)
Source: "dist\ZKTeco-Sync.exe"; DestDir: "{app}"; Flags: ignoreversion
; Servicio de Windows
Source: "dist\zkteco_service.exe"; DestDir: "{app}"; Flags: ignoreversion
; Scripts de instalación/desinstalación del servicio
Source: "install_service.bat"; DestDir: "{app}"; DestName: "install_service.bat"; Flags: ignoreversion
Source: "uninstall_service.bat"; DestDir: "{app}"; DestName: "uninstall_service.bat"; Flags: ignoreversion
; Documentación
Source: "README.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "requirements.txt"; DestDir: "{app}"; Flags: ignoreversion

[Icons]
Name: "{group}\ZKTeco Sync"; Filename: "{app}\ZKTeco-Sync.exe"
Name: "{group}\Instalar Servicio"; Filename: "{app}\install_service.bat"; IconFilename: "{sys}\shell32.dll"; IconIndex: 21
Name: "{group}\Desinstalar Servicio"; Filename: "{app}\uninstall_service.bat"; IconFilename: "{sys}\shell32.dll"; IconIndex: 131
Name: "{group}\Verificar Estado"; Filename: "http://127.0.0.1:3322/estado"; IconFilename: "{sys}\shell32.dll"; IconIndex: 14
Name: "{group}\Desinstalar ZKTeco Sync"; Filename: "{uninstallexe}"
Name: "{autodesktop}\ZKTeco Sync"; Filename: "{app}\ZKTeco-Sync.exe"; Tasks: desktopicon

[Run]
; CAMBIO PRINCIPAL: Instalar servicio directamente desde Pascal, no desde BAT
Filename: "{app}\ZKTeco-Sync.exe"; Description: "Ejecutar ZKTeco Sync"; Flags: nowait postinstall skipifsilent unchecked

[UninstallDelete]
Type: filesandordirs; Name: "{app}\logs"
Type: filesandordirs; Name: "{app}\config"

[Code]
// FUNCIÓN MEJORADA: Verificar privilegios de administrador
function IsAdmin(): Boolean;
begin
  Result := IsAdminLoggedOn or IsPowerUserLoggedOn;
end;

// FUNCIÓN CORREGIDA: Log detallado para debugging
procedure LogInstallStep(Step: String; Success: Boolean; Details: String);
var
  LogFile: String;
  LogContent: TStringList;
  LogLine: String;
begin
  try
    LogFile := ExpandConstant('{app}\logs\installer.log');
    CreateDir(ExtractFileDir(LogFile));
    
    LogContent := TStringList.Create;
    try
      if FileExists(LogFile) then
        LogContent.LoadFromFile(LogFile);
      
      // Línea simple sin timestamp
      if Success then
        LogLine := Step + ': SUCCESS'
      else
        LogLine := Step + ': FAILED';
      
      if Details <> '' then
        LogLine := LogLine + ' - ' + Details;
      
      LogContent.Add(LogLine);
      LogContent.SaveToFile(LogFile);
    finally
      LogContent.Free;
    end;
  except
    // Fallar silenciosamente si no se puede escribir log
  end;
end;

// FUNCIÓN CORREGIDA: Crear configuración por defecto
function CreateDefaultDeviceConfig(): Boolean;
var
  ConfigDir, ConfigFile: String;
  ConfigContent: TStringList;
begin
  Result := False;
  try
    ConfigDir := ExpandConstant('{app}\config');
    ConfigFile := ConfigDir + '\device.json';
    
    // Crear directorio si no existe
    if not DirExists(ConfigDir) then
      CreateDir(ConfigDir);
    
    LogInstallStep('CreateConfigDir', DirExists(ConfigDir), ConfigDir);
    
    if not FileExists(ConfigFile) then
    begin
      ConfigContent := TStringList.Create;
      try
        ConfigContent.Add('{');
        ConfigContent.Add('  "id": "1",');
        ConfigContent.Add('  "name": "Dispositivo ZKTeco",');
        ConfigContent.Add('  "ip_address": "192.168.1.100",');
        ConfigContent.Add('  "port": 4370');
        ConfigContent.Add('}');
        
        ConfigContent.SaveToFile(ConfigFile);
        Result := FileExists(ConfigFile);
        LogInstallStep('CreateDefaultConfig', Result, ConfigFile);
      finally
        ConfigContent.Free;
      end;
    end else begin
      Result := True;
      LogInstallStep('ConfigAlreadyExists', True, ConfigFile);
    end;
  except
    LogInstallStep('CreateDefaultConfig', False, GetExceptionMessage);
  end;
end;

// FUNCIÓN NUEVA: Verificar que el ejecutable del servicio existe
function ValidateServiceExecutable(): Boolean;
var
  ServiceExe: String;
begin
  ServiceExe := ExpandConstant('{app}\zkteco_service.exe');
  Result := FileExists(ServiceExe);
  LogInstallStep('ValidateServiceExe', Result, ServiceExe);
end;

// FUNCIÓN NUEVA: Detener servicio existente de forma robusta
function StopExistingService(): Boolean;
var
  ResultCode: Integer;
  Attempts: Integer;
begin
  Result := True;
  LogInstallStep('StopExistingService', True, 'Starting...');
  
  // Detener el servicio si está ejecutándose
  if Exec(ExpandConstant('{cmd}'), '/c net stop ZKTecoSync', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
  begin
    LogInstallStep('NetStop', ResultCode = 0, 'Code: ' + IntToStr(ResultCode));
  end;
  
  // Esperar hasta 10 segundos para que se detenga
  Attempts := 0;
  while (Attempts < 10) do
  begin
    Sleep(1000);
    if Exec(ExpandConstant('{cmd}'), '/c sc query ZKTecoSync | findstr STOPPED', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    begin
      if ResultCode = 0 then
      begin
        LogInstallStep('ServiceStopped', True, 'After ' + IntToStr(Attempts + 1) + ' seconds');
        Break;
      end;
    end;
    Attempts := Attempts + 1;
  end;
end;

// FUNCIÓN NUEVA: Eliminar servicio existente de forma robusta
function RemoveExistingService(): Boolean;
var
  ResultCode: Integer;
  ServiceExists: Boolean;
begin
  Result := True;
  
  // Verificar si el servicio existe
  ServiceExists := False;
  if Exec(ExpandConstant('{cmd}'), '/c sc query ZKTecoSync', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
  begin
    ServiceExists := (ResultCode = 0);
    LogInstallStep('CheckServiceExists', ServiceExists, 'Code: ' + IntToStr(ResultCode));
  end;
  
  if ServiceExists then
  begin
    // Método 1: Usar el ejecutable del servicio
    if Exec(ExpandConstant('{app}\zkteco_service.exe'), 'remove', ExpandConstant('{app}'), SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    begin
      LogInstallStep('ServiceRemoveMethod1', ResultCode = 0, 'Code: ' + IntToStr(ResultCode));
      if ResultCode = 0 then
      begin
        Sleep(2000);
        Exit;
      end;
    end;
    
    // Método 2: Usar sc delete como respaldo
    if Exec(ExpandConstant('{cmd}'), '/c sc delete ZKTecoSync', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    begin
      LogInstallStep('ServiceRemoveMethod2', ResultCode = 0, 'Code: ' + IntToStr(ResultCode));
    end;
    
    Sleep(3000); // Dar tiempo para que Windows procese la eliminación
  end;
end;

// FUNCIÓN PRINCIPAL CORREGIDA: Instalar servicio con validaciones robustas
function InstallZKTecoService(): Boolean;
var
  ResultCode: Integer;
  ServiceInstalled, ServiceStarted: Boolean;
  Attempts: Integer;
begin
  Result := False;
  ServiceInstalled := False;
  ServiceStarted := False;
  
  LogInstallStep('InstallService', True, 'Starting installation process...');
  
  try
    // 1. Verificar privilegios
    if not IsAdmin() then
    begin
      LogInstallStep('AdminCheck', False, 'Insufficient privileges');
      Exit;
    end;
    LogInstallStep('AdminCheck', True, 'Administrator privileges confirmed');
    
    // 2. Validar que el ejecutable existe
    if not ValidateServiceExecutable() then
    begin
      LogInstallStep('ValidateExe', False, 'Service executable not found');
      Exit;
    end;
    
    // 3. Crear directorios necesarios
    CreateDir(ExpandConstant('{app}\logs'));
    CreateDir(ExpandConstant('{app}\config'));
    LogInstallStep('CreateDirectories', True, 'Logs and config directories created');
    
    // 4. Crear archivo de configuración por defecto
    if not CreateDefaultDeviceConfig() then
    begin
      LogInstallStep('CreateConfig', False, 'Could not create default config');
      // No es crítico, continuar
    end;
    
    // 5. Detener servicio existente
    StopExistingService();
    
    // 6. Eliminar servicio existente
    RemoveExistingService();
    
    // 7. Instalar nuevo servicio
    LogInstallStep('InstallNewService', True, 'Installing new service...');
    if Exec(ExpandConstant('{app}\zkteco_service.exe'), 'install', ExpandConstant('{app}'), SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    begin
      ServiceInstalled := (ResultCode = 0);
      LogInstallStep('ServiceInstall', ServiceInstalled, 'Code: ' + IntToStr(ResultCode));
      
      if ServiceInstalled then
      begin
        Sleep(2000); // Dar tiempo para que se registre el servicio
        
        // 8. Configurar inicio automático
        if Exec(ExpandConstant('{cmd}'), '/c sc config ZKTecoSync start= auto', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
        begin
          LogInstallStep('ConfigAutoStart', ResultCode = 0, 'Code: ' + IntToStr(ResultCode));
        end;
        
        // 9. Configurar descripción
        if Exec(ExpandConstant('{cmd}'), '/c sc description ZKTecoSync "Servicio de sincronización para dispositivos ZKTeco - API REST en puerto 3322"', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
        begin
          LogInstallStep('SetDescription', ResultCode = 0, 'Code: ' + IntToStr(ResultCode));
        end;
        
        Sleep(1000);
        
        // 10. Iniciar servicio con reintentos
        Attempts := 0;
        while (Attempts < 3) and (not ServiceStarted) do
        begin
          if Exec(ExpandConstant('{cmd}'), '/c net start ZKTecoSync', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
          begin
            ServiceStarted := (ResultCode = 0);
            LogInstallStep('StartService', ServiceStarted, 'Attempt ' + IntToStr(Attempts + 1) + ', Code: ' + IntToStr(ResultCode));
            
            if ServiceStarted then
            begin
              Sleep(5000); // Dar tiempo para que el servicio se inicie completamente
              Break;
            end else begin
              Sleep(2000); // Esperar antes del siguiente intento
            end;
          end;
          Attempts := Attempts + 1;
        end;
        
        Result := ServiceStarted;
      end;
    end else begin
      LogInstallStep('ServiceInstall', False, 'Failed to execute install command');
    end;
    
  except
    LogInstallStep('InstallService', False, 'Exception: ' + GetExceptionMessage);
    Result := False;
  end;
  
  LogInstallStep('InstallServiceComplete', Result, 'Final result');
end;

// FUNCIÓN MEJORADA: Verificar estado del servicio
function IsServiceRunning(): Boolean;
var
  ResultCode: Integer;
  Attempts: Integer;
begin
  Result := False;
  
  // Intentar varias veces para dar tiempo al servicio
  Attempts := 0;
  while (Attempts < 5) and (not Result) do
  begin
    try
      // Método 1: Verificar que el puerto esté escuchando
      if Exec(ExpandConstant('{cmd}'), '/c netstat -ano | findstr ":3322.*LISTENING"', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
      begin
        if ResultCode = 0 then
        begin
          Result := True;
          LogInstallStep('ServiceRunningCheck', True, 'Port 3322 is listening');
          Break;
        end;
      end;
      
      Sleep(2000);
      Attempts := Attempts + 1;
    except
      // Continuar con el siguiente intento
    end;
  end;
  
  if not Result then
    LogInstallStep('ServiceRunningCheck', False, 'Port 3322 not listening after 5 attempts');
end;

procedure CurStepChanged(CurStep: TSetupStep);
var
  ServiceSuccess: Boolean;
  StatusMsg: String;
begin
  if CurStep = ssPostInstall then
  begin
    if IsTaskSelected('installservice') then
    begin
      LogInstallStep('PostInstall', True, 'Starting service installation...');
      
      ServiceSuccess := InstallZKTecoService();
      
      if ServiceSuccess then
      begin
        // Verificar que realmente esté ejecutándose
        if IsServiceRunning() then
        begin
          StatusMsg := 'La instalación se completó correctamente.' + #13#10 + #13#10 +
                      '✓ Servicio ZKTeco Sync instalado y ejecutándose' + #13#10 +
                      '✓ API REST disponible en: http://127.0.0.1:3322' + #13#10 + #13#10 +
                      'Para verificar el estado visite: http://127.0.0.1:3322/estado' + #13#10 + #13#10 +
                      'IMPORTANTE: Configure su dispositivo editando:' + #13#10 +
                      ExpandConstant('{app}\config\device.json');
                      
          LogInstallStep('InstallationComplete', True, 'Service running successfully');
        end else
        begin
          StatusMsg := 'El servicio se instaló pero puede tardar en iniciar.' + #13#10 + #13#10 +
                      'Espere unos segundos y verifique en: http://127.0.0.1:3322/estado' + #13#10 + #13#10 +
                      'Si no funciona, ejecute "Instalar Servicio" desde el menú de inicio';
          
          LogInstallStep('InstallationComplete', False, 'Service installed but not running yet');
        end;
      end else
      begin
        StatusMsg := 'No se pudo instalar el servicio automáticamente.' + #13#10 + #13#10 +
                    'Para instalarlo manualmente:' + #13#10 +
                    '1. Ejecute "Instalar Servicio" desde el menú de inicio' + #13#10 +
                    '2. Asegúrese de ejecutar como Administrador' + #13#10 + #13#10 +
                    'Logs de instalación en: ' + ExpandConstant('{app}\logs\installer.log');
        
        LogInstallStep('InstallationComplete', False, 'Automatic installation failed');
      end;
      
      MsgBox(StatusMsg, mbInformation, MB_OK);
    end;
  end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  ResultCode: Integer;
begin
  if CurUninstallStep = usUninstall then
  begin
    if MsgBox('¿Desea eliminar también el servicio ZKTeco Sync?' + #13#10 + 
              '(Recomendado para una desinstalación completa)', 
              mbConfirmation, MB_YESNO) = IDYES then
    begin
      // Detener servicio
      Exec(ExpandConstant('{cmd}'), '/c net stop ZKTecoSync', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
      Sleep(3000);
      
      // Intentar eliminar usando el ejecutable
      if FileExists(ExpandConstant('{app}\zkteco_service.exe')) then
      begin
        Exec(ExpandConstant('{app}\zkteco_service.exe'), 'remove', 
             ExpandConstant('{app}'), SW_HIDE, ewWaitUntilTerminated, ResultCode);
        Sleep(2000);
      end;
      
      // Si falla, intentar eliminación manual
      if ResultCode <> 0 then
        Exec(ExpandConstant('{cmd}'), '/c sc delete ZKTecoSync', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
    end;
  end;
end;